This query simulates having daily snapshots of the NetsuiteTransaction table and then processes that history to produce the desired SCD format with effective dates.

The Goal

We want to transform a log of daily statuses into a table that shows the exact period during which each status was active for a transaction.

From this (Daily Snapshots):

snapshot_date	transaction_id	status
2025-08-01	    101	            Pending Approval
2025-08-02	    101	            Pending Approval
2025-08-03	    101	            Approved
2025-08-04	    101	            Approved
2025-08-05	    101	            Shipped

To this (Type 2 SCD Table):

transaction_id	status	            effective_start_date	effective_end_date
101	            Pending Approval	2025-08-01	            2025-08-02
101	            Approved	        2025-08-03	            2025-08-04
101	            Shipped	            2025-08-05	            9999-12-31


Proof-of-Concept SQL Query



-- Step 1: Simulate the source data.
        -- In a real scenario, this would be a table that is appended daily  (Snap shot table)
        -- with a snapshot of all relevant transactions and their current status.

WITH DailySnapshots AS (
    SELECT
        CAST('2025-08-01' AS DATE) AS snapshot_date, 101 AS transaction_id, 'Pending Approval' AS status UNION ALL
    SELECT '2025-08-02', 101, 'Pending Approval' UNION ALL
    SELECT '2025-08-03', 101, 'Approved'         UNION ALL -- Status changed
    SELECT '2025-08-04', 101, 'Approved'         UNION ALL
    SELECT '2025-08-05', 101, 'Shipped'          UNION ALL -- Status changed again
    SELECT '2025-08-06', 101, 'Shipped'          UNION ALL

    -- Transaction 102 never changes status
    SELECT '2025-08-02', 102, 'Pending Fulfillment' UNION ALL
    SELECT '2025-08-03', 102, 'Pending Fulfillment' UNION ALL
    SELECT '2025-08-04', 102, 'Pending Fulfillment' UNION ALL

    -- Transaction 103 is new and has not changed yet
    SELECT '2025-08-06', 103, 'Billed'
),

-- Step 2: Identify when the status changes for each transaction.
-- We use the LAG() window function to compare the current status with the 
-- previous day's status.

StatusChangeEvents AS (
    SELECT
        transaction_id,
        status,
        snapshot_date,
        LAG(status) OVER (PARTITION BY transaction_id ORDER BY snapshot_date) AS previous_status
    FROM
        DailySnapshots
),

-- Step 3: Filter for only the rows that represent the start of a new period.
-- This includes the very first time we see a transaction (previous_status is NULL)
-- or any time the status value actually changes.

EffectiveStarts AS (
    SELECT
        transaction_id,
        status,
        snapshot_date AS effective_start_date
    FROM
        StatusChangeEvents
    WHERE
        previous_status IS NULL OR status <> previous_status
)

-- Step 4: Construct the final SCD table.
-- Use the LEAD() window function to find the start date of the *next* period,
-- which we use to calculate the end date of the *current* period.

SELECT
    transaction_id,
    status,
    effective_start_date,
    -- The end date is one day before the next period starts.
    -- We use DATEADD() for date math.
    ISNULL(
        DATEADD(day, -1, LEAD(effective_start_date) OVER (PARTITION BY transaction_id ORDER BY effective_start_date)),
        '9999-12-31'
    ) AS effective_end_date
FROM
    EffectiveStarts
ORDER BY
    transaction_id,
    effective_start_date;



Expected Output

Running the query above will produce the following result, which is a perfect Type 2 SCD table.

transaction_id	status	            effective_start_date	effective_end_date
101	            Pending Approval	2023-08-01	            2023-08-02
101	            Approved	        2023-08-03	            2023-08-04
101	            Shipped	            2023-08-05	            9999-12-31
102	            Pending Fulfillment	2023-08-02	            9999-12-31
103	            Billed	            2023-08-06	            9999-12-31


How to Use This in a Real System

Source Table:    we would first create a process that runs daily, queries Netsuite.transaction, 
                 and appends the transaction_id and status along with the current date into a history table (our DailySnapshots table).

ETL/ELT Process: The SQL logic above would then be run (e.g., in a stored procedure ) against this history table. 
                 It would typically truncate and reload the final SCD destination table, as it's easier and safer to rebuild the entire 
                 history each time than to manage individual updates to the effective_end_date column.

Performance:     For a very large number of transactions, this full rebuild might become slow. At that point, 
                 we can optimize the process to only update the effective_end_date of recently changed records, 
                 but the logic above is the correct starting point for the initial build and for validating the methodology.


